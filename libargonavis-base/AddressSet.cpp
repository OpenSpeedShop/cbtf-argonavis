////////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2013 Krell Institute. All Rights Reserved.
// Copyright (c) 2015 Argo Navis Technologies. All Rights Reserved.
//
// This library is free software; you can redistribute it and/or modify it under
// the terms of the GNU Lesser General Public License as published by the Free
// Software Foundation; either version 2.1 of the License, or (at your option)
// any later version.
//
// This library is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
// FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more
// details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with this library; if not, write to the Free Software Foundation, Inc.,
// 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
////////////////////////////////////////////////////////////////////////////////

/** @file Definition of the AddressSet class. */

#include <boost/assert.hpp>
#include <boost/bind.hpp>
#include <boost/dynamic_bitset.hpp>
#include <boost/function.hpp>
#include <boost/optional.hpp>
#include <boost/ref.hpp>
#include <sstream>
#include <utility>

#include <ArgoNavis/Base/AddressSet.hpp>
#include <ArgoNavis/Base/Raise.hpp>

using namespace ArgoNavis::Base;



/** Anonymous namespace hiding implementation details. */
namespace {

    /**
     * Virtual machine used to construct and/or execute a bytecode program that
     * represents an address set. In the interest of storing large, fragmented,
     * address sets compactly, they are represented as bytecode programs. These
     * bytecode programs contain one or more variable-length instructions which,
     * when executed, generate the contiguous address ranges in the address set.
     *
     * ...
     *
     * @sa http://en.wikipedia.org/wiki/Virtual_machine
     * @sa http://en.wikipedia.org/wiki/Bytecode
     */
    class VirtualMachine
    {
        
    public:

        /** Type of container used to store a bytecode program. */
        typedef std::vector<boost::uint8_t> Program;
        
        /**
         * Construct a virtual machine for executing the specified bytecode
         * program beginning at that program's first instruction.
         *
         * @param program    Bytecode program to be executed.
         *
         * @note    This class stores a reference to, rather than a copy of,
         *          the bytecode program; improving performance by avoiding
         *          unnecessary copies. Thus it is critical that the caller
         *          insures the program's scope exceeds that of the virtual
         *          machine's.
         */
        VirtualMachine(Program& program) :
            dm_program(program),
            dm_pc(0),
            dm_range()
        {
        }
        
        /**
         * Append a new address range at the end of the address set represented
         * by the bytecode program. This is accomplished by adding one or more
         * new instructions at the end of the program.
         *
         * @param range    Address range to be appended to the bytecode program.
         *
         * @throw std::runtime_error    This virtual machine's PC isn't at
         *                              the end of the bytecode program.
         */
        void append(const AddressRange& range)
        {
            if (!end())
            {
                raise<std::runtime_error>("This virtual machine's PC isn't at"
                                          "the end of the bytecode program.");
            }
            
            // ...
        }
        
        /** Has execution reached the end of the bytecode program? */
        bool end() const
        {
            return dm_pc == dm_program.size();
        }
        
        /**
         * Get the next address range generated by the bytecode program. This
         * is accomplished by continuing execution of the program until a new
         * contiguous address range is generated.
         *
         * @return    Next address range generated by the bytecode program.
         *
         * @throw std::runtime_error    This virtual machine's PC is at
         *                              the end of the bytecode program.
         */
        const AddressRange& next()
        {
            if (end())
            {
                raise<std::runtime_error>("This virtual machine's PC is at"
                                          "the end of the bytecode program.");
            }
            
            // ...
            
            return *dm_range;
        }
        
        /** Redirection to an output stream. Intended for debugging use only. */
        friend std::ostream& operator<<(std::ostream& stream,
                                        const VirtualMachine& vm)
        {
            // ...
            
            return stream;
        }
        
    private:

        /** Bytecode program being executed by this virtual machine. */
        Program& dm_program;

        /**
         * Index within that byte program of the next instruction to execute.
         * I.e. the program counter.
         *
         * @sa http://en.wikipedia.org/wiki/Program_counter
         */
        Program::size_type dm_pc;
        
        /** Previous address range generated by the bytecode program. */
        boost::optional<AddressRange> dm_range;
        
    }; // class VirtualMachine

    /**
     * Visit contiguous address ranges covering all possible addresses from
     * Address::TheLowest() to Address::TheHighest() such that each visited
     * address range is entirely inside or outside each of the two specified
     * address sets.
     *
     * @param program_x    Bytecode program defining the first address set.
     * @param program_y    Bytecode program defining the second address set.
     *     
     * @param visitor      Visitor called for each address range. The visitor
     *                     is passed a reference to the address range and two
     *                     booleans indicating whether it is inside (true) or
     *                     outside (false) each of the two address sets.
     *
     * @note    This function is used with the buildXYZ() visitors below to
     *          implement the various overloaded operators for AddressSet.
     */
    void visit(const VirtualMachine::Program& program_x,
               const VirtualMachine::Program& program_y,
               boost::function<void (const AddressRange&, bool, bool)> visitor)
    {
        VirtualMachine vm_x(const_cast<VirtualMachine::Program&>(program_x));
        VirtualMachine vm_y(const_cast<VirtualMachine::Program&>(program_y));
        
        bool found_a_range = false;
        Address i = Address::TheLowest();
        AddressRange range_x, range_y;
        
        while (!vm_x.end() || !vm_y.end())
        {
            //
            // Obtain the next address range in each of the two address sets,
            // as necessary, bearing in mind that the end of one or the other
            // address set may have been reached.
            //
            
            if (range_x.empty() && !vm_x.end())
            {
                range_x = vm_x.next();
                found_a_range = true;
            }
            
            if (range_y.empty() && !vm_y.end())
            {
                range_y = vm_y.next();
                found_a_range = true;
            }
            
            //
            // If the next beginning of an address range inside either address
            // set is greater than the current position (i), visit that range,
            // which is outside both address sets.
            //
            
            Address next = 
                range_x.empty() ? range_y.begin() :
                range_y.empty() ? range_x.begin() :
                std::min(range_x.begin(), range_y.begin());
            
            if (next > i)
            {
                visitor(AddressRange(i, next - 1), false, false);
            }
            
            //
            // If the next address range inside either address set is disjoint
            // from the other address set, visit that range, which is inside
            // one or the other address set. I.e. handle the 6 cases:
            //
            // x: *****           x: *****           x: *****
            // y:                 y:      *****      y:       *****
            //
            // x:                 x:      *****      x:       *****
            // y: *****           y: *****           y: *****
            //
            
            if (range_y.empty() || (range_x.end() < range_y.begin()))
            {
                visitor(range_x, true, false);
                i = range_x.end() + 1;
                range_x = AddressRange();
            }
            
            else if (range_x.empty() || (range_y.end() < range_x.begin()))
            {
                visitor(range_y, false, true);
                i = range_y.end() + 1;
                range_y = AddressRange();
            }

            //
            // If the next address range inside each address set intersect, and
            // the beginning of each address range is identical, visit the range
            // that is shared in common, which is inside both address sets. I.e.
            // handle the 3 cases:
            //
            // x: *****           x: ***             x: *****
            // y: *****           y: *****           y: ***
            //
            
            else if (range_x.begin() == range_y.begin())
            {
                if (range_x.end() == range_y.end())
                {
                    visitor(range_x, true, true);
                    i = range_x.end() + 1;
                    range_x = AddressRange();
                    range_y = AddressRange();
                }
                else if (range_x.end() < range_y.end())
                {
                    visitor(range_x, true, true);
                    i = range_x.end() + 1;
                    range_x = AddressRange();
                    range_y = AddressRange(i, range_y.end());
                }
                else
                {
                    visitor(range_y, true, true);
                    i = range_y.end() + 1;
                    range_x = AddressRange(i, range_x.end());
                    range_y = AddressRange();
                }
            }
            
            //
            // If the next address range inside each address set intersect, and
            // the beginning of each address range is different, visit the part
            // of the next address range which is not shared in common, which
            // is inside one or the other address set. I.e. handle the 2 cases:
            //
            // x: *****           x:   *****
            // y:   *****         y: *****
            //
            
            else if (range_x.begin() < range_y.begin())
            {
                visitor(AddressRange(range_x.begin(), range_y.begin() - 1),
                        true, false);
                i = range_y.begin();
                range_x = AddressRange(i, range_x.end());
            }
            
            else if (range_y.begin() < range_x.begin())
            {
                visitor(AddressRange(range_y.begin(), range_x.begin() - 1),
                        false, true);
                i = range_x.begin();
                range_y = AddressRange(i, range_y.end());
            }
            
            //
            // All possible cases should be handled by the above. The following
            // is simply a sanity check that this is, in fact, the case.
            //
            
            else
            {
                BOOST_ASSERT(false);
            }
        }
        
        //
        // If the current position (i) didn't wrap around to the first possible
        // address, visit the remaining range, which is outside both address
        // sets. Also handle the special case where both address sets are empty,
        // in which case all possible addresses are outside both address sets.
        //
        
        if (!found_a_range || (i > Address::TheLowest()))
        {
            visitor(AddressRange(i, Address::TheHighest()), false, false);
        }
    }
    
    /** Visitor used to build the difference of two address sets. */
    void buildDifference(VirtualMachine& result,
                         const AddressRange& range,
                         bool inside_x, bool inside_y)
    {
        if (inside_x & !inside_y)
        {
            result.append(range);
        }
    }

    /** Visitor used to build the intersection of two address sets. */
    void buildIntersection(VirtualMachine& result,
                           const AddressRange& range,
                           bool inside_x, bool inside_y)
    {
        if (inside_x & inside_y)
        {
            result.append(range);
        }
    }
    
    /** Visitor used to build the negation of an address set. */
    void buildNegation(VirtualMachine& result,
                       const AddressRange& range,
                       bool inside, bool /* Unused */)
    {
        if (!inside)
        {
            result.append(range);
        }
    }
    
    /** Visitor used to build the sum of two address sets. */
    void buildSum(VirtualMachine& result,
                  const AddressRange& range,
                  bool inside_x, bool inside_y)
    {
        if (inside_x | inside_y)
        {
            result.append(range);
        }
    }
    
    /** Visitor used to build the symmetric difference of two address sets. */
    void buildSymmetricDifference(VirtualMachine& result,
                                  const AddressRange& range,
                                  bool inside_x, bool inside_y)
    {
        if (inside_x != inside_y)
        {
            result.append(range);
        }
    }

    /** Visitor used to build the union of two address sets. */
    void buildUnion(VirtualMachine& result,
                    const AddressRange& range,
                    bool inside_x, bool inside_y)
    {
        if (inside_x | inside_y)
        {
            result.append(range);
        }
    }

    /** Visitor used to redirect an address set to an output stream. */
    bool redirect(std::ostream& stream, bool& first, const AddressRange& range)
    {
        if (!first)
        {
            stream << ", ";
        }
        stream << range;
        first = false;
        return true;
    }

} // namespace <anonymous>



//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
AddressSet::AddressSet() :
    dm_data()
{
}



//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
AddressSet::AddressSet(const Address& address) :
    dm_data()
{
    VirtualMachine vm(dm_data);

    vm.append(address);
}



//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
AddressSet::AddressSet(const AddressRange& range) :
    dm_data()
{
    VirtualMachine vm(dm_data);

    vm.append(range);
}



//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
AddressSet::AddressSet(CBTF_Protocol_AddressBitmap* messages, u_int len) :
    dm_data()
{
    VirtualMachine vm(dm_data);

    // ...
}



//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
AddressSet::AddressSet(const CBTF_Protocol_AddressBitmap& message) :
    dm_data()
{
    VirtualMachine vm(dm_data);

    // Convert the message's raw address bitmap into a more usable form
    boost::dynamic_bitset<boost::uint8_t> bitmap;
    for (u_int i = 0; i < message.bitmap.data.data_len; ++i)
    {
        bitmap.append(message.bitmap.data.data_val[i]);
    }
    
    // Iterate over each address in this address bitmap
    bool inside = false;
    Address begin;
    for (boost::dynamic_bitset<boost::uint8_t>::size_type i = 0;
         (i < bitmap.size()) &&
             ((message.range.begin + i) <= message.range.end);
         ++i)
    {
        // Is this address the beginning of an address range?
        if (!inside && bitmap[i])
        {
            inside = true;
            begin = message.range.begin + i;
        }

        // Is this address the end of an address range?
        else if (inside && !bitmap[i])
        {
            inside = false;
            vm.append(AddressRange(begin, message.range.begin + i - 1));
        }
    }
    
    // Does a range end at the end of the address bitmap?
    if (inside)
    {
        vm.append(AddressRange(begin, message.range.end - 1));
    }
}



//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
AddressSet::operator std::string() const
{
    std::ostringstream stream;
    stream << *this;
    return stream.str();
}



//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
bool AddressSet::operator==(const AddressSet& other) const
{
    return (*this ^ other).empty();
}



//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
void AddressSet::operator~()
{
    VirtualMachine::Program data, empty;
    VirtualMachine vm(data);

    ::visit(dm_data, empty,
            boost::bind(buildNegation, boost::ref(vm), _1, _2, _3));
    
    dm_data.swap(data);
}



//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
AddressSet& AddressSet::operator|=(const AddressSet& other)
{
    VirtualMachine::Program data;
    VirtualMachine vm(data);

    ::visit(dm_data, other.dm_data,
            boost::bind(buildUnion, boost::ref(vm), _1, _2, _3));

    dm_data.swap(data);
    return *this;
}



//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
AddressSet& AddressSet::operator&=(const AddressSet& other)
{
    VirtualMachine::Program data;
    VirtualMachine vm(data);

    ::visit(dm_data, other.dm_data,
            boost::bind(buildIntersection, boost::ref(vm), _1, _2, _3));

    dm_data.swap(data);    
    return *this;
}



//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
AddressSet& AddressSet::operator^=(const AddressSet& other)
{
    VirtualMachine::Program data;
    VirtualMachine vm(data);

    ::visit(dm_data, other.dm_data,
            boost::bind(buildSymmetricDifference, boost::ref(vm), _1, _2, _3));

    dm_data.swap(data);
    return *this;
}



//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
AddressSet& AddressSet::operator+=(const AddressSet& other)
{
    VirtualMachine::Program data;
    VirtualMachine vm(data);

    ::visit(dm_data, other.dm_data,
            boost::bind(buildSum, boost::ref(vm), _1, _2, _3));

    dm_data.swap(data);
    return *this;
}



//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
AddressSet& AddressSet::operator-=(const AddressSet& other)
{
    VirtualMachine::Program data;
    VirtualMachine vm(data);

    ::visit(dm_data, other.dm_data,
            boost::bind(buildDifference, boost::ref(vm), _1, _2, _3));

    dm_data.swap(data);
    return *this;
}



//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
bool AddressSet::contains(const AddressSet& other) const
{
    return (*this | other) == *this;
}



//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
bool AddressSet::empty() const
{
    return dm_data.empty();
}



//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
void AddressSet::extract(CBTF_Protocol_AddressBitmap*& messages,
                         u_int& len) const
{
    // ...
}


        
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
bool AddressSet::intersects(const AddressSet& other) const
{
    return !(*this & other).empty();
}


        
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
void AddressSet::visit(const AddressRangeVisitor& visitor) const
{
    VirtualMachine vm(const_cast<VirtualMachine::Program&>(dm_data));
    
    for (bool terminate = false; !terminate && !vm.end();)
    {
        terminate |= !visitor(vm.next());
    }
}



//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
std::ostream& ArgoNavis::Base::operator<<(std::ostream& stream,
                                          const AddressSet& set)
{
    bool first = true;

    stream << "{ ";
    set.visit(boost::bind(redirect, boost::ref(stream), boost::ref(first), _1));
    stream << (first ? "" : " ") << "}";

    return stream;
}
